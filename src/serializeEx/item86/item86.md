## Serializable 을 구현할지는 신중히 결정하라

### Serializable 을 구현하면 릴리즈 한 뒤에는 수정하기 어렵다.    
커스텀 직렬화 형태를 설계하지 않고 자바의 기본 방식을 사용하면
직렬화 형태는 최초 적용 당시 클래스의 내부 구현 방식에 영원히 묶인다.

기본 직렬화 형태에서는 클래스의 private 과 package-private 인스턴스 필드들마저 API로 공개된다.

따라서 가능 클래스를 만들고자 한다면, 길게 보고 감당할 수 있을 만큼 고품질의 직렬화 형태를 설계해야 한다.

직렬 버전 UID(serial version UID) : 클래스 이름, 구현한 인터페이스, 대부분의 클래스 멤버들이 수정되는 경우 직렬 버전 UID 값도 변한다.
-> InvalidClassException 발생


### 버그와 보안 구멍
객체는 생성자를 사용해 만드는 게 기본이다. 직렬화는 이를 우회하여 생성한다.   
기본 역직렬화를 사용하면 불변식이 깨짐과 동시에 허가되지 않은 접근에 쉽게 노출된다. 

### 테스트 증가
해당 클래스의 신버전을 릴리즈할 때 테스트할 것이 늘어난다.   

구버전으로 역직렬화할 수 있는지, 또는 그 반대도 가능한지 검사해야 한다. -> 릴리즈 횟수에 비례해 증가한다.

### Serializable 구현 여부
BigInteger, Instant 같은 값 클래스와 컬렉션은 Serializable 을 구현하고, 스레드 풀처럼 동작하는 객체를 표현하는 클래스들은 대부분 구현하지 않았다.  

상속용 클래스는 대부분 Serializable 을 구현하면 안 되며, 인터페이스도 대부분 Serializable 을 확장해서는 안 된다.

클래스가 직렬화와 확장이 모두 가능하고 불변식을 보장해야 할 게 있다면 하위클래스에서 finalize 메서드를 재정의하지 못하게 해야 한다.
해당 메서드를 재정의하면서 final 로 선언한다.

### 구현하지 않을 때
상속용 클래스인데 직렬화를 지원하지 않으면 하위 클래스에서 직렬화를 지원하려 할 때 부담이 늘어난다. 
역직렬화하려면 상위 클래스는 매개변수가 없는 생성자를 제공해야 하는데, 
제공하지 않으면 하위 클래스에서는 직렬화 프로시 패턴을 사용해야 한다. 

내부 클래스는 직렬화를 구현하지 말아야 한다. 내부클래스에는 컴파일러가 생성한 필드들이 자동으로 추가된다.
단, 정적 멤버 클래스는 Serializable 을 구현해도 된다.